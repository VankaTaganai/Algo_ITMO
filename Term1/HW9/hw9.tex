\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{fancyvrb}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}


\title{Homework}
\date{24-11-2019}
\author{Panov Ivan, M3139}


\begin{document}
	\pagenumbering{gobble}
	
	\maketitle
	\newpage
	\pagenumbering{arabic}
	
	\section*{Задача 1}
	Введем функцию $f(i)$ - количиство непустых различных подпоследовательностей заканчивающихся на префиксе длины $i$. Подсчет функции будет осуществляться из предыдущих значений: $f(i) = 2f(i - 1) - f(j - 1)$, где $j$ является индексом предыдущего вхождения числа $a_i$. Докажем корректность: поймем, что $f(i - 1)$ просто общее количесво последовательностей на префиксе длины $i - 1$ (по определению). Тогда нам нужно учесть все старые последовательности и последовательности, которые заканчиваются в $i$ (из этого мы умножем в формуле перехода на $2$). Если мы припишем ко всем уже найденным последовательностям $a_i$, то некоторые можно посчитать несколько раз, следовательно их нужно вычесть из общей суммы. Не трудно понять, что этими лишними последовательностями будут все заканчивающеся раньше $j$, так как с приписанным $a_i$ они были подсчитаны на $j$-ом шагу ($a_i = a_j$), что и является $f(j - 1)$. Теперь научимся считать переходы за $\mathcal{O}(n)$, $n$ - количество чисел. Будем поддерживать массив со значениями функции $cnt$, где $cnt_i = f(i)$. Так же будем хранить массив $ind$, где $ind_x$ последний индекс, на котором в исходном массиве встречается $x$ на данной итерации. Теперь опишем процесс: $del = cnt_{i-1} - cnt_{ind_{a[i]} - 1}$ - лишние последовательности, переприсвоим индекс $ind_{a[i]} = i$, посчитаем функцию $cnt_i = 2cnt_{i - 1} - del + 1$. Будем считать, что если число $x$ не встречалось, то $del = 0$, так как нужно учесть последовательность состоящюю только из нового символа. Итоговое время работы $\mathcal{O}(n)$.
	
	\section*{Задача 2}
	Докажем правильность алгоритма. Очевидно, что максимальный палиндром является общей подпоследовательностью $a$ и $a^r$. Пусть мы нашли максимальную последовательность, которая не является палиндромом длины $n$. Поделим эту последовательность по среднему элементу, если такой есть, или пополам. Обозначим левую часть за $s_l$, а правую $s_r$. Теперь поделим или по среднему символу, или по вхождению $s_l$ последовательности $a$ ($a_l$, $a_r$) и $a^r$ ($a_l^r$ и $a_r^r$). $s_l$ подпоследовательность $a_l^r$ и $a_l$ из построения, а так как $a^r$ это перевернутая $a$, то $s_l^r$ подпоследовательность $a_r$, следовательно можно найти палиндромную последовательность длины $n$ состоящую из $s_l + (middle\ element) + s_l^r$. Алгоритм доказан.
	
	\section*{Задача 3}
	Для решения данной задачи придется воспользоваться алгоритмом поиска наибольшей возрастающей последовательности за $\mathcal{O}(n\log(n))$, только теперь будем хранить не только последний элемент на который заканчивается префикс, а список всех возможных элементов вместе с индексами, для каждого элемента номер списка, для каждого списка количество элементов, в котором оно хранится, заметим, что элементы в этих списках будут в порядке убывания по построению. Теперь найдя какое-то НВП, мы также нашли все возможные ВП на префиксе в неявном виде. Для востановления ответа понадобится строить НВП проходясь начиная с конца, данный алгоритм будет отличатся только поиском не первого большего, а первого меньшего элемента. Востановление ответа проходит по следующему алгоритму: когда мы найдем суффикс НВП который заканчивается в элементе $a_i$, мы узнаем длину этого суффикса, пусть длина $k$, чтобы узнать лежит ли $a_i$ в НВП посмотрим есть ли $a_i$ в списке НВП для префикса длины $n - k + 1$. При том если список состоит только из $a_i$, то $a_i$ лежит во всех НВП, а если мы не нашли $a_i$ в списке, то этот элемент не лежит ни в одной НВП. После обратки символа надо совершить переход: нужно уменьшить счетчик количества элементов в списке на префиксе для этого элемента, так как элемент больше не встретится на большем суффиксе. Поиск по списку осуществляется бинарным поиском, так как элементы в отсортированном порядке. Докажем корректность: определение принадлежности хотя бы одной последовательности очевидно, так как можно сказать мы просто нашли префикс и суффикс правильной НВП, пренадлежность всем определяется правильно, так как префикс опреденной длины может заканчиваться только одним символом, что гарантирует принадлежность этого элемента всем НВП, а те элементы которые не лежат нигде просто оставшиеся.
	
	
\end{document}
